MEMORY
{
    ROM     (r  ) : ORIGIN = 0x00000000, LENGTH = 16K
    FLASH   (rx ) : ORIGIN = 0x10000000, LENGTH = 2M
    RAM     (rwx) : ORIGIN = 0x20000000, LENGTH = 256K

    /* The ROM will load the first 256 bytes from FLASH into RAM into this range. */
    BOOTRAM (rwx) : ORIGIN = 0x20041f00, LENGTH = 256
}

/* This entry point is not used when we boot correctly, however, if the 'continue' command is used instead of 'run', we will start here. */
/* In that case we will simply hit a breakpoint. */
ENTRY(boot_1_debugger);

SECTIONS
{
    /* This is the first 256 bytes that will be loaded from FLASH into RAM by the ROM. */
    .boot_2_flash : {
        KEEP (*(.boot_2_flash))
    } > BOOTRAM AT > FLASH

    /* Everything that can stay in flash, we don't care about code versus data. */
    .text : {
        __text_start__ = .;

        KEEP (*(.vectors))
        *(.text*)
        *(.rodata*)

        /* This is generated by the linker. */
        /* My understanding is, that sometimes the linker needs to make a larger workaround and it can't inline that code all the time. */
        /* Instead, the code is moved into these sections, however, this is very poorly documented. */
        *(.glue_7t) *(.glue_7) *(.vfp11_veneer) *(.v4_bx)

        . = ALIGN(4);
        __text_end__ = .;
    } > FLASH AT > FLASH

    /* The following is needed for dynamic linking. */
    /* Our boot loader and kernel is statically linked, but we still need to provide this for some reason. */
    .rel.dyn : {
        *(.rel.iplt)
    }
    .got : {
        *(.igot.plt)
    }
    .iplt : { *(.iplt) }

    /* The C++20 modules all seem to define a global constructor that should run before main. */
    /* It places a pointer to each function in this area, we can iterate it on startup. */
    .init_array : {
        __init_array_start__ = .;
        KEEP (*(.init_array))
        __init_array_end__ = .;
    } > FLASH AT > FLASH

    /* Anything that needs to be copied into RAM before the kernel starts. */
    .data : {
        __data_start__ = .;

        *(.data*)

        . = ALIGN(4);
        __data_end__ = .;
    } > RAM AT > FLASH
    __data_lma__ = LOADADDR(.data);

    /* Anything that needs to be in RAM but doesn't exist in FLASH. */
    .bss (NOLOAD) : {
        __bss_start__ = .;

        *(.bss*)

        . = ALIGN(4);
        __bss_end__ = .;
    } > RAM AT > RAM

    /* When we load the kernel, we need some place to store global variables that are used by the loading logic itself. */
    /* If this were put into '.bss' or '.data' it would be overwritten. */
    .noinit (NOLOAD) : {
        __noinit_start__ = .;
        *(.noinit*)

        . = ALIGN(4);
        __noinit_end__ = .;
    } > RAM AT > RAM

    /* The linker decides where our boot stack is. */
    /* Later, the kernel will take over memory management and then this won't matter at all. */
    .bootstack (NOLOAD) : {
        . += 0x1000;
        . = ALIGN(8);
        boot_stack_top = .;
    } > RAM AT > RAM

    __end__ = .;

    /* There are tons of other sections, that we explicitly mention here. */
    /* If the compiler mentions something that isn't in this list, this is usually an error and the section should be added with care. */
    /* Note the '0' after the section name, this means that this section is placed at address zero, by default it will continue incrementing addresses. */

    .ARM.attributes 0 : { KEEP (*(.ARM.attributes)) }
    .comment 0 : { *(.comment) }
    .debug_line 0 : { *(.debug_line) }
    .debug_line_str 0 : { *(.debug_line_str) }
    .debug_info 0 : { *(.debug_info) }
    .debug_abbrev 0 : { *(.debug_abbrev) }
    .debug_aranges 0 : { *(.debug_aranges) }
    .debug_str 0 : { *(.debug_str) }
    .debug_frame 0 : { *(.debug_frame) }
    .symtab 0 : { *(.symtab) }
    .strtab 0 : { *(.strtab) }
    .shstrtab 0 : { *(.shstrtab) }
}
