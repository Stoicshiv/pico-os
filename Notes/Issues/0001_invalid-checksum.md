I suspect that my `checksum.py` script is producing an incorrect checksum.

-   I've used `objcopy` and xxd to extract the contents of the `.boot_2_flash_second_stage` section:

    ```none
    00000000: 0d 21 30 bf fc e7 00 00 00 00 00 00 00 00 00 00  .!0.............
    00000010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    00000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    00000040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    00000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    00000060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    00000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    00000080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    00000090: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    000000a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    000000b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    000000c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    000000d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    000000e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    000000f0: 00 00 00 00 00 00 00 00 00 00 00 00 84 7b 16 d6  .............{..
    ```

    In comparison, here is what the `pad_checksum` script will produce:

    ```none
    .byte 0x0d, 0x21, 0x30, 0xbf, 0xfc, 0xe7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x3a, 0xbf, 0x00
    ```

    Clearly, I am computing the checksum wrong and this isn't just a byte order thing.

-   This is the code that the `pad_checksum` script uses:

    ```python
    def bitrev(x, width):
        return int("{:0{w}b}".format(x, w=width)[::-1], 2)

    # Our bootrom CRC32 is slightly bass-ackward but it's best to work around for now (FIXME)
    # 100% worth it to save two Thumb instructions
    checksum = bitrev(
        (binascii.crc32(bytes(bitrev(b, 8) for b in idata_padded), args.seed ^ 0xffffffff) ^ 0xffffffff) & 0xffffffff, 32)
    odata = idata_padded + struct.pack("<L", checksum)
    ```

-   It turns out that I forgot to truncate the input to 252 bytes.
